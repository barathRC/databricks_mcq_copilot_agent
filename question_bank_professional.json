[
  {
    "question_id": "P001",
    "domain": "Delta Optimization",
    "difficulty": "professional",
    "question_text": "A gold table is queried with filters on event_date and customer_id. What is the best optimization?",
    "choices": {
      "A": "Random repartition",
      "B": "Partition by event_date and Z-ORDER by customer_id",
      "C": "Disable Photon engine",
      "D": "Convert table to CSV"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Partition aligns data with date filters; Z-ORDER improves skipping for customer_id.",
      "options": {
        "A": "Random repartitioning does not optimize filters.",
        "C": "Photon improves performance.",
        "D": "CSV reduces performance drastically."
      }
    }
  },
  {
    "question_id": "P002",
    "domain": "DLT Expectations",
    "difficulty": "professional",
    "question_text": "You want strict rules for critical columns but only metric tracking for others. Which DLT config works?",
    "choices": {
      "A": "expect_or_fail for all rules",
      "B": "expect_or_drop + expect (metric-only)",
      "C": "expect for all rules",
      "D": "No expectations"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Strict rules drop invalid rows; metric-only rules track without blocking.",
      "options": {
        "A": "Too strict for soft rules.",
        "C": "Lacks enforcement.",
        "D": "Ignores data quality."
      }
    }
  },

  {
    "question_id": "P003",
    "domain": "Streaming",
    "difficulty": "professional",
    "question_text": "Why is watermarking required for stateful aggregations?",
    "choices": {
      "A": "To autoscale the cluster",
      "B": "To drop old state based on event-time progress",
      "C": "To guarantee exactly-once",
      "D": "To reduce checkpoint size"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Watermarks clean out old state safely.",
      "options": {
        "A": "Autoscaling is separate.",
        "C": "Checkpointing handles exactly-once.",
        "D": "Checkpoint size not directly controlled."
      }
    }
  },

  {
    "question_id": "P004",
    "domain": "Workflows",
    "difficulty": "professional",
    "question_text": "You need Auto Loader → DLT → Dashboard refresh → Slack alert. Use:",
    "choices": {
      "A": "Notebook chaining",
      "B": "Databricks Workflows with dependent tasks",
      "C": "DLT alone",
      "D": "Manual notebook execution"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Workflows support multi-step pipelines and alerts.",
      "options": {
        "A": "No automation.",
        "C": "DLT cannot refresh dashboards.",
        "D": "Not scalable."
      }
    }
  },

  {
    "question_id": "P005",
    "domain": "Lineage",
    "difficulty": "professional",
    "question_text": "Which feature visualizes upstream tables feeding a gold table?",
    "choices": {
      "A": "DESCRIBE HISTORY",
      "B": "Unity Catalog Lineage",
      "C": "VACUUM",
      "D": "Event Logs"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Lineage shows upstream/downstream relationships.",
      "options": {
        "A": "History shows commits only.",
        "C": "Cleans up files only.",
        "D": "Logs show runtime info."
      }
    }
  },

  {
    "question_id": "P006",
    "domain": "Delta MERGE",
    "difficulty": "professional",
    "question_text": "Which operation handles SCD Type 1 upserts?",
    "choices": {
      "A": "INSERT",
      "B": "MERGE INTO",
      "C": "DELETE + INSERT ALL",
      "D": "UPDATE without join"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "MERGE handles matched and unmatched rows properly.",
      "options": {
        "A": "INSERT produces duplicates.",
        "C": "Inefficient.",
        "D": "Updates all rows blindly."
      }
    }
  },

  {
    "question_id": "P007",
    "domain": "Join Skew",
    "difficulty": "professional",
    "question_text": "Which technique mitigates skew in joins?",
    "choices": {
      "A": "Disable AQE",
      "B": "Apply salting",
      "C": "Use one partition",
      "D": "Convert to CSV"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Salting distributes skewed values across partitions.",
      "options": {
        "A": "AQE helps, not hurts.",
        "C": "One partition kills parallelism.",
        "D": "CSV is slow."
      }
    }
  },

  {
    "question_id": "P008",
    "domain": "Delta Optimization",
    "difficulty": "professional",
    "question_text": "Small files degrade query performance. Which helps?",
    "choices": {
      "A": "OPTIMIZE and Z-ORDER",
      "B": "VACUUM 0 HOURS",
      "C": "Disable cache",
      "D": "Reduce cluster size"
    },
    "correct_answer": "A",
    "explanation": {
      "correct": "OPTIMIZE compacts files; Z-ORDER improves skipping.",
      "options": {
        "B": "Dangerous and breaks time travel.",
        "C": "Caching improves performance.",
        "D": "Does not address files."
      }
    }
  },

  {
    "question_id": "P009",
    "domain": "External Locations",
    "difficulty": "professional",
    "question_text": "To govern cloud object storage in Unity Catalog, you must first:",
    "choices": {
      "A": "Mount the location via dbutils",
      "B": "Create a Storage Credential",
      "C": "Copy files into DBFS root",
      "D": "Use cluster init scripts"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Storage credentials authenticate UC to cloud storage.",
      "options": {
        "A": "Legacy and bypasses UC.",
        "C": "Not needed.",
        "D": "Unrelated to UC."
      }
    }
  },

  {
    "question_id": "P010",
    "domain": "Photon Engine",
    "difficulty": "professional",
    "question_text": "Photon improves performance by:",
    "choices": {
      "A": "Row-based execution",
      "B": "Vectorized SQL engine optimized for Delta",
      "C": "Disabling statistics",
      "D": "Skipping caching"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Photon is a vectorized engine for SQL workloads.",
      "options": {
        "A": "Photon is columnar.",
        "C": "Stats remain useful.",
        "D": "Cache still works."
      }
    }
  },

  {
    "question_id": "P011",
    "domain": "Streaming MERGE",
    "difficulty": "professional",
    "question_text": "Which pattern supports near-exactly-once semantics in foreachBatch?",
    "choices": {
      "A": "Append only",
      "B": "MERGE with unique IDs + checkpointing",
      "C": "Disable checkpoints",
      "D": "Trigger.Once"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "MERGE prevents duplicates when combined with checkpointing.",
      "options": {
        "A": "Duplicates may occur.",
        "C": "Cannot recover offsets.",
        "D": "Runs only once."
      }
    }
  },

  {
    "question_id": "P012",
    "domain": "DLT",
    "difficulty": "professional",
    "question_text": "Which DLT mode supports near-real-time updates?",
    "choices": {
      "A": "Triggered batch",
      "B": "Continuous mode",
      "C": "Paused mode",
      "D": "Offline mode"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Continuous mode keeps streaming tables updated.",
      "options": {
        "A": "Batch is intermittent.",
        "C": "Paused mode not processing.",
        "D": "Not DLT mode."
      }
    }
  },

  {
    "question_id": "P013",
    "domain": "Unity Catalog",
    "difficulty": "professional",
    "question_text": "How do you implement row-level security?",
    "choices": {
      "A": "Dynamic views with row filters",
      "B": "VACUUM",
      "C": "Cluster ACLs only",
      "D": "Disable DESCRIBE"
    },
    "correct_answer": "A",
    "explanation": {
      "correct": "Row filters restrict data per-user/group.",
      "options": {
        "B": "File cleanup only.",
        "C": "Does not limit table visibility.",
        "D": "Not related."
      }
    }
  },

  {
    "question_id": "P014",
    "domain": "AQE",
    "difficulty": "professional",
    "question_text": "AQE improves performance by:",
    "choices": {
      "A": "Fixing query plan early",
      "B": "Adapting join strategies at runtime",
      "C": "Removing partitioning",
      "D": "Disabling broadcast joins"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "AQE optimizes joins & partitions dynamically.",
      "options": {
        "A": "Opposite of AQE.",
        "C": "Not true.",
        "D": "AQE may add broadcast joins."
      }
    }
  },

  {
    "question_id": "P015",
    "domain": "Architecture",
    "difficulty": "professional",
    "question_text": "Which aligns to Databricks Lakehouse best practices?",
    "choices": {
      "A": "Bronze → Silver → Gold",
      "B": "Single giant table",
      "C": "Raw CSV for BI",
      "D": "Notebook-only ETL"
    },
    "correct_answer": "A",
    "explanation": {
      "correct": "Medallion architecture is the core Lakehouse pattern.",
      "options": {
        "B": "Unscalable design.",
        "C": "Low performance.",
        "D": "Not governed."
      }
    }
  },

  {
    "question_id": "P016",
    "domain": "Security",
    "difficulty": "professional",
    "question_text": "Where should external secret keys be stored?",
    "choices": {
      "A": "Notebook variables",
      "B": "Unity Catalog Secrets",
      "C": "Cluster environment logs",
      "D": "Job parameters"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "UC Secrets store sensitive credentials securely.",
      "options": {
        "A": "Not secure.",
        "C": "Highly insecure.",
        "D": "Visible to job readers."
      }
    }
  },

  {
    "question_id": "P017",
    "domain": "Streaming Scaling",
    "difficulty": "professional",
    "question_text": "A streaming job must process 100k events/sec. Best option?",
    "choices": {
      "A": "Single-node cluster",
      "B": "Autoscaling cluster with optimized shuffle",
      "C": "Coalesce to 1 partition",
      "D": "Triggered daily batch"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Autoscaling adapts to data rate variations.",
      "options": {
        "A": "Not distributed.",
        "C": "Kills throughput.",
        "D": "Not streaming."
      }
    }
  },

  {
    "question_id": "P018",
    "domain": "Governance",
    "difficulty": "professional",
    "question_text": "To separate duties between data engineers and consumers:",
    "choices": {
      "A": "Use Unity Catalog privileges",
      "B": "Use dbutils mounts",
      "C": "Share admin credentials",
      "D": "Disable permissions"
    },
    "correct_answer": "A",
    "explanation": {
      "correct": "UC enables granular access control.",
      "options": {
        "B": "Mounts bypass UC.",
        "C": "Security risk.",
        "D": "Breaks governance."
      }
    }
  },

  {
    "question_id": "P019",
    "domain": "DLT Testing",
    "difficulty": "professional",
    "question_text": "How do you test DLT pipelines safely?",
    "choices": {
      "A": "Deploy to prod immediately",
      "B": "Use DLT development mode with sampling",
      "C": "Use notebooks only",
      "D": "Disable expectations"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Dev mode accelerates testing.",
      "options": {
        "A": "Risky.",
        "C": "Not DLT pipeline logic.",
        "D": "Expectations ensure quality."
      }
    }
  },

  {
    "question_id": "P020",
    "domain": "Databricks SQL",
    "difficulty": "professional",
    "question_text": "Which feature accelerates BI workload refresh?",
    "choices": {
      "A": "Materialized Views",
      "B": "Trigger.Once",
      "C": "CSV caching",
      "D": "Stream-stream joins"
    },
    "correct_answer": "A",
    "explanation": {
      "correct": "Materialized Views incrementally refresh efficiently.",
      "options": {
        "B": "Not continuous.",
        "C": "Not a performance feature.",
        "D": "Not BI-specific."
      }
    }
  },

  {
    "question_id": "P021",
    "domain": "Unity Catalog",
    "difficulty": "professional",
    "question_text": "Which privilege is needed for CREATE TABLE?",
    "choices": {
      "A": "MODIFY",
      "B": "CREATE on schema",
      "C": "EXECUTE",
      "D": "BROWSE"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "CREATE allows creating objects in a schema.",
      "options": {
        "A": "MODIFY edits existing tables.",
        "C": "EXECUTE applies to functions.",
        "D": "Not a UC privilege."
      }
    }
  },

  {
    "question_id": "P022",
    "domain": "Optimization",
    "difficulty": "professional",
    "question_text": "To reduce large scan cost, use:",
    "choices": {
      "A": "Z-ORDER",
      "B": "DQ filtering only",
      "C": "CSV files",
      "D": "Shuffle off"
    },
    "correct_answer": "A",
    "explanation": {
      "correct": "Z-ORDER clusters data for efficient skipping.",
      "options": {
        "B": "Filtering doesn't change layout.",
        "C": "CSV degrades performance.",
        "D": "Shuffle needed for joins."
      }
    }
  },

  {
    "question_id": "P023",
    "domain": "End-to-End",
    "difficulty": "professional",
    "question_text": "Which Lakehouse pattern supports both batch and streaming?",
    "choices": {
      "A": "Bronze → Silver → Gold",
      "B": "Single raw table",
      "C": "Daily CSV loads",
      "D": "Notebook-only pipelines"
    },
    "correct_answer": "A",
    "explanation": {
      "correct": "Medallion architecture supports multi-hop and multimodal ETL.",
      "options": {
        "B": "Not scalable.",
        "C": "Not low-latency.",
        "D": "Hard to manage."
      }
    }
  },

  {
    "question_id": "P024",
    "domain": "Advanced Workflows",
    "difficulty": "professional",
    "question_text": "Downstream tasks should run only when upstream succeeds. Configure:",
    "choices": {
      "A": "No dependencies",
      "B": "Task dependencies with 'on success'",
      "C": "Disabling retries",
      "D": "Increasing cluster size"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Workflows support conditional task execution.",
      "options": {
        "A": "Runs all tasks regardless.",
        "C": "Retries unrelated.",
        "D": "Not dependency logic."
      }
    }
  },

  {
    "question_id": "P025",
    "domain": "Retention",
    "difficulty": "professional",
    "question_text": "To keep long time-travel while controlling cost:",
    "choices": {
      "A": "Set long retention + matching VACUUM",
      "B": "Retention = 0 hours",
      "C": "Never VACUUM",
      "D": "Delete delta logs"
    },
    "correct_answer": "A",
    "explanation": {
      "correct": "Aligning retention with VACUUM preserves history while controlling file growth.",
      "options": {
        "B": "Breaks time-travel.",
        "C": "Storage grows infinitely.",
        "D": "Corrupts table."
      }
    }
  }
]
