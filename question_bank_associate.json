[
  {
    "question_id": "A001",
    "domain": "Delta Lake",
    "difficulty": "associate",
    "question_text": "Which Delta Lake feature enables users to query previous versions of a table for debugging and audit purposes?",
    "choices": {
      "A": "Z-Ordering",
      "B": "Schema Evolution",
      "C": "Time Travel via Transaction Log",
      "D": "Optimize Write"
    },
    "correct_answer": "C",
    "explanation": {
      "correct": "Delta Time Travel uses the transaction log to query older table versions.",
      "options": {
        "A": "Z-Ordering improves data skipping but not historical access.",
        "B": "Schema evolution updates table structure, not past versions.",
        "D": "Optimize Write improves file layout."
      }
    }
  },
  {
    "question_id": "A002",
    "domain": "Structured Streaming",
    "difficulty": "associate",
    "question_text": "To ensure exactly-once semantics when writing to Delta Lake, which must be configured?",
    "choices": {
      "A": "Trigger.Once",
      "B": "Checkpoint Location",
      "C": "Caching",
      "D": "Watermark"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Checkpointing stores offsets for recovery and exactly-once delivery.",
      "options": {
        "A": "Trigger.Once processes once then stops.",
        "C": "Caching does not affect reliability.",
        "D": "Watermark controls late data, not exactly-once guarantees."
      }
    }
  },
  {
    "question_id": "A003",
    "domain": "Unity Catalog",
    "difficulty": "associate",
    "question_text": "Which Unity Catalog object represents the highest-level governance boundary?",
    "choices": {
      "A": "Schema",
      "B": "Catalog",
      "C": "Metastore",
      "D": "Volume"
    },
    "correct_answer": "C",
    "explanation": {
      "correct": "The metastore governs catalogs, schemas, tables, and more.",
      "options": {
        "A": "Schemas live inside catalogs.",
        "B": "Catalogs belong to a metastore.",
        "D": "Volumes store files, not governance boundaries."
      }
    }
  },
  {
    "question_id": "A004",
    "domain": "Auto Loader",
    "difficulty": "associate",
    "question_text": "Which Auto Loader mode avoids repeated directory scanning for new files?",
    "choices": {
      "A": "Schema Hints",
      "B": "File Notification Mode",
      "C": "Directory-Based Mode Only",
      "D": "Manual REST File Listing"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "File Notification Mode uses cloud events to detect new files.",
      "options": {
        "A": "Schema hints guide column inference.",
        "C": "Directory listing scales poorly.",
        "D": "REST-based listing is not recommended."
      }
    }
  },
  {
    "question_id": "A005",
    "domain": "Spark Optimization",
    "difficulty": "associate",
    "question_text": "A small table is joined with a very large fact table. What optimization improves join performance?",
    "choices": {
      "A": "Disable Broadcast Joins",
      "B": "Broadcast the small table",
      "C": "Coalesce both to one partition",
      "D": "Convert both to CSV"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Broadcasting avoids shuffling the large table.",
      "options": {
        "A": "Broadcasting is helpful, not harmful.",
        "C": "Coalescing kills parallelism.",
        "D": "CSV increases IO overhead."
      }
    }
  },
  {
    "question_id": "A006",
    "domain": "Delta Lake",
    "difficulty": "associate",
    "question_text": "Which setting enables automatic schema evolution on write?",
    "choices": {
      "A": "spark.sql.shuffle.partitions",
      "B": "spark.databricks.delta.schema.autoMerge.enabled",
      "C": "spark.databricks.delta.minReaderVersion",
      "D": "spark.sql.files.maxRecordsPerFile"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "autoMerge enables schema evolution.",
      "options": {
        "A": "Sets shuffle partitions.",
        "C": "Controls protocol compatibility.",
        "D": "Controls file sizes."
      }
    }
  },
  {
    "question_id": "A007",
    "domain": "Unity Catalog",
    "difficulty": "associate",
    "question_text": "Which privilege is required to create a table in a schema?",
    "choices": {
      "A": "USAGE",
      "B": "CREATE",
      "C": "MODIFY",
      "D": "EXECUTE"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "CREATE allows creating new objects such as tables.",
      "options": {
        "A": "USAGE allows referencing the schema only.",
        "C": "MODIFY affects existing tables.",
        "D": "EXECUTE applies to functions."
      }
    }
  },
  {
    "question_id": "A008",
    "domain": "Streaming",
    "difficulty": "associate",
    "question_text": "What does watermarking primarily control?",
    "choices": {
      "A": "Processing rate",
      "B": "State cleanup of old events",
      "C": "Cluster autoscaling",
      "D": "Exactly-once behavior"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "Watermarks signal when old state can be discarded.",
      "options": {
        "A": "Separate rate control mechanisms exist.",
        "C": "Autoscaling is independent.",
        "D": "Exactly-once is controlled by checkpoints."
      }
    }
  },
  {
    "question_id": "A009",
    "domain": "Delta CDF",
    "difficulty": "associate",
    "question_text": "Which API returns only changed rows from a Delta table with CDF enabled?",
    "choices": {
      "A": "SELECT * FROM table",
      "B": "table_changes()",
      "C": "VACUUM",
      "D": "DESCRIBE HISTORY"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "table_changes() returns CDF rows between versions.",
      "options": {
        "A": "Returns full table.",
        "C": "Removes old files.",
        "D": "Shows commit metadata only."
      }
    }
  },
  {
    "question_id": "A010",
    "domain": "BI Compute",
    "difficulty": "associate",
    "question_text": "Which compute type is designed for BI dashboards?",
    "choices": {
      "A": "All-purpose clusters",
      "B": "Job clusters",
      "C": "SQL Warehouses",
      "D": "Developer laptops"
    },
    "correct_answer": "C",
    "explanation": {
      "correct": "SQL Warehouses offer concurrency and autoscaling for BI.",
      "options": {
        "A": "All-purpose clusters are for interactive development.",
        "B": "Job clusters are for ETL jobs.",
        "D": "Not scalable for BI."
      }
    }
  },

  {
    "question_id": "A011",
    "domain": "Delta Lake",
    "difficulty": "associate",
    "question_text": "What does OPTIMIZE do?",
    "choices": {
      "A": "Deletes unreferenced files",
      "B": "Compacts small files",
      "C": "Upgrades table protocol",
      "D": "Performs indexing"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "OPTIMIZE merges many small files into larger ones.",
      "options": {
        "A": "VACUUM removes unreferenced files.",
        "C": "Protocol upgrades use different commands.",
        "D": "Delta has no separate index command."
      }
    }
  },

  {
    "question_id": "A012",
    "domain": "DLT",
    "difficulty": "associate",
    "question_text": "DLT expectations allow which behavior?",
    "choices": {
      "A": "Only schema enforcement",
      "B": "Data quality checks with drop or metric-only actions",
      "C": "Cluster creation",
      "D": "Retry logic"
    },
    "correct_answer": "B",
    "explanation": {
      "correct": "DLT expectations handle data quality with configurable behavior.",
      "options": {
        "A": "Expectations go beyond schema.",
        "C": "Clusters are managed separately.",
        "D": "Retries belong to Workflows."
      }
    }
  },

  {
    "question_id": "A013",
    "domain": "Spark",
    "difficulty": "associate",
    "question_text": "What does repartition(n) do?",
    "choices": {
